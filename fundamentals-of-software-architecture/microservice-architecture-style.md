# 마이크로

# 서론

- 마이크로서비스는 도메인 주도 설계 사상의 영향을 많이 받았다.
- 경계 컨텐스트 개념에 결정적인 영향을 받음
- 재사용은 유익하지만 커플링이 문제이다. 디커플링이 아키텍처의 목표라면 중복을 우선시한다.
- **마이크로서비스의 주요 목표는 경계 콘텍스트의 논리적 개념을 물리적으로 모델링하는 고도의 디커플링이다.**

# 토폴로지

<img width="533" alt="image" src="https://github.com/leehjhjhj/reading-books/assets/102458609/a508e125-7cda-4de4-9b6c-0401a5ddf1ca">


- 서비스 규모가 작고, 각 서비스에는 데이터베이스 및 기타 종속적인 컴포넌트가 독립적으로 작동

# 분산

- 마이크로서비스는 분산 아키텍처를 형성
- 클라우드 리소스와 컨테이너 기술을 이용해 도메인, 운영 레벨 모두 디커플링 가능하여, 이점이 많음
- 네트워크 호출이다 보니 성능은 다소 부정적. 그래서 서비스 세분도를 심사숙고 해야한다.

# 경계 콘텍스트

- 마이크로서비스의 근본 철학
- 서비스마다 도메인이나 워크플로우를 모델링하는 개념
- 각각의 마이크로서비스는 한 도메인이나 서브 도메인을 나타내어, DDD의 논리적인 개념을 물리적으로 구현한 것

## 세분도

- 서비스를 너무 잘게 자르는 실수를 자주 범함
- 서비스 경계는 도메인이나 워크플로를 캡처하는 것이 목표.

## 서비스 경계 찾기

- 트랜잭션을 단위로
- 코레오그래피: 도메인 격리가 잘 되어있지만, 서로 광범위한 통신을 해야할 때 다시 큰 서비스로 뭉쳐야할 수도 있음. 즉 좋은 서비스 설계안은 지속적인 **이터레이션**이 중요.

## 데이터 격리

- 경계 컨텍스트 개념에 따라 데이터 격리
- 공유 스키마, 데이터베이스 등 모든 종류 커플링을 없애기
- **데이터 격리**는 아키텍트가 서비스 세분도를 살피 때 반드시 고려

# API 레이어

- 필수는 아니나 대부분 있다.
- 프록시를 경유하여 간접화
- 네이밍 서비스 같은 운영 장치를 물린다.
- API 레이어를 중재자나 오케스트레이션 도구로 사용하면 안된다.

# 운영 재사용

- 모니터링, 로깅, 회로 차단기 같은 운영 관심사는 사이드카 패턴을 사용한다.

<img width="515" alt="image" src="https://github.com/leehjhjhj/reading-books/assets/102458609/99cd3a5a-2bd4-4f48-b9be-312743b499aa">


- 각 서비스마다 별도의 컴포넌트로 둔다. 이를 인프라 팀이나 해당 팀에 소유
- 서비스 메시를 구축하면 모니터링, 로깅 등을 일원화하여 제어가 가능하다.

<img width="515" alt="image" src="https://github.com/leehjhjhj/reading-books/assets/102458609/d07ff533-258c-4b31-83c9-42cd51fe2cfb">


- 서비스 메시 자체는 개발자가 서비스를 전체적으로 엑세스 할 수 있는 콘솔 역할을 한다.
- 요청이 왔을 때, **서비스 디스커버리 도구**를 거치게 하여 모니터링에 용이하게 함 ****

# 프론트엔드

- 유저 인터페이스와 백엔드도 분리되는 것이 좋다.
- 단일 유저 인터페이스가 API레이어를 통해 호출하는 모놀리식 유저 인터페이스

<img width="519" alt="image" src="https://github.com/leehjhjhj/reading-books/assets/102458609/7e537784-1312-4083-8c33-7102a7adf13a">


- 위 사진과 같이 유저 인터페이스 레벨의 컴포넌트를 백엔드 서비스로 활용하여 동기적인 수준으로 세분화하는 마이크로프론트엔드
- 유저인터페이스부터 백엔드 서비스까지 서비스 경계를 분리

# 통신

- 동기로 할지? 비동기로 할지?
- 대부분은 프로토콜 인지 이종 간 상호 운용성을 활용
    - 프로토콜 인지: 운영 커플링을 방지하고자 중앙 통합 허브가 없다. 각 서비스는 다른 서비스를 호출하는 방법을 알고 있어야 함.
    - 이종: 서비스마다 구현 기술 스택이 상이
    - 상호 운영성: 여러 서비스가 서로 호출한다. 내부적으로 이벤트 기반 아키텍처를 활용

## 코레오그래피와 오케스트레이션

<img width="515" alt="image" src="https://github.com/leehjhjhj/reading-books/assets/102458609/ff904bf0-044e-429a-87db-cfa2a5ae2b92">


- 코레오그래피는 브로커 이벤트 기반의 아키텍처. 중재자가 없어 경계 콘텍스트에 충실

<img width="503" alt="image" src="https://github.com/leehjhjhj/reading-books/assets/102458609/3e3ebbde-cec6-4232-8b82-404c09bae7cd">


- 여러 서비스를 중재할 때 이렇게 로컬 중재자를 만들 수 있다.

<img width="523" alt="image" src="https://github.com/leehjhjhj/reading-books/assets/102458609/69f4d93d-045c-4b87-bac2-083e47f8ab53">


- 이렇게 복잡해지면 프런트 컨트롤 패턴이 생긴다.
- 처음 호출된 서비스가 다른 서비스를 전체적으로 조정하는 중재자 역할을 수행
<img width="521" alt="image" src="https://github.com/leehjhjhj/reading-books/assets/102458609/748c8f97-0eca-4ab9-9818-66d130bd2826">


- 이렇게 비지니스 워크플로와 같은 중재자를 두면 커플링이 발생.
- 하지만 이 서비스만 조정을 담당하므로 다른 서비스에 영향은 주지 않는다.

## 트랜잭션과 사가

- 모놀리식 애플리케이션과 달리 원자성 문제가 대두
- 서비스 경계를 넘나드는 트랜잭션은 설계 단계에서 지나치게 세분화 한 것.

<img width="541" alt="image" src="https://github.com/leehjhjhj/reading-books/assets/102458609/0c11b0bf-5a8c-4907-b8cf-db921f8236c6">


- 위가 사가패턴이라고 한다.
- 서비스는 여러 서비스 호출에 대해 중재장 역할을 하고, 트랜잭션을 조정한다.
- 중재자는 트랜잭션을 구성하는 파트를 하나씩 호출하여 실패/성공 여부를 기록하고, 만일 하나가 실패할 경우 과거의 내용을 모두 undo 요청을 날린다.
- 이런 것을 트랜잭션 프레임워크라고 한다.
- 여러 서비스에 트랜잭션을 걸어주는 것이 기술적으로 불가능은 아니지만 이러면 마이크로서비스를 택할 이유가 없다.
- 그러나 예외는 있기마련, 필요한 경우 사가 패턴을 조금씩 곁들여 사용하라
