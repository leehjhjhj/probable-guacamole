# 서비스기반

# 서비스 기반 아키텍처 스타일

## 서론

- 마이크로서비스 아키텍처 스타일의 일종
- 아키텍처가 유연해서 가장 실용적인 아키텍처 스타일 중 하나이다.
- 비교적 덜 복잡하고 비용이 많이 들지 않는다.

## 토폴로지
![image](https://github.com/leehjhjhj/reading-books/assets/102458609/05e05366-3d0a-4a0c-9231-2c2a8632d5ea)

- 각각 따로 배포된 유저 인터페이스
- 원격 서비스
- 모놀리스 데이터베이스로 이루어진 대규모 분산 레이어 구조
- 여기서 서비스는 별도로 배포하는 애플리케이션의 일부(도메인 서비스)
- 개수는 4~12개, 평균 7개 정도
- 중앙 공유 데이터베이스를 사용

## 토폴로지 변형
![image](https://github.com/leehjhjhj/reading-books/assets/102458609/9cfd4bca-e9ad-4f92-8a40-4b718f89ae23)

- 유저 인터페이스를 유저 인터페이스 도메인으로 나눌 수 있다.
- 개별 데이터베이스로 분리할 수 있다. <br>

![image](https://github.com/leehjhjhj/reading-books/assets/102458609/6c433d90-6dfa-40c3-9ee5-c460dd2eb64a)

- 리버스 프록시 or 게이트웨이로 구성된 API레이어를 유저 인터페이스와 서비스 사이에 구성 할 수 있다.
- 도메인 서비스의 일부를 외부 시스템으로 떼어내거나
- 공통 관심사로 통합해서 유저 인터페이스 밖으로 뗄 수도 있다.

## 서비스 설계 및 세분도
![image](https://github.com/leehjhjhj/reading-books/assets/102458609/36f21289-b9b0-4ce2-ae72-5820285f0359)

- 도메인 서비스는 API 퍼사드 레이어, 비지니스 레이어, 퍼시스턴스 레이어로 구성된 아키텍처로 설계하는 것이 일반적
- 모듈러 모놀리스 아키텍처 스타일처럼 서브 도메인을 사용하여 도메인 서비스를 분리하기도 함
- 유저 인터페이스에서 비지니스 기능을 호출하기 위해 일종의 API 액세스 퍼사드를 필요로 함
    - API 액세스 퍼사드는 비지니스 요청을 오케스트레이트하는 역할
    - 주문 → OrderService 도메인 서비스의 API 액세스 퍼사드가 받음
    - 주문 처리, 주문 ID생성, 결제처리 → 재고 정보 업데이트를 하여 오크스트레이트함
    - 내부 클래스 수준에서 오스트레이션이라는 점에서 마이크로 서비스와 차이점
- 도메인 서비스는 단일 도메인 서비스의 데이터 무결성을 위해 ACID 트랜잭션을 사용
- 그렇지만 마이크로 서비스는 BASE 트랜잭션이라는 분산 트랜잭션 기법 사용
- 이는 최종 일관성 기반이라 서비스 기반 아키텍처는 ACID 데이터 무결성은 지원 X
- 도메인 서비스 단위가 커서 데이터 무결성과 일관성 측면에는 유리하지만, 변경 영향도에서 트레이드 오프가 있다.

## 데이터베이스 분할
![image](https://github.com/leehjhjhj/reading-books/assets/102458609/8374315f-fdba-4ee3-8d46-f239c5d033cb)

- 테이블 스키마를 나타낸 클래스 파일(엔티티)는 전체 도메인 서비스가 이용하는 커스텀 공유 라이브러리에 둔다.
- 하지만 이는 비효율적인 구현 방법인데, 테이블을 바꾸면 사용여부와 상관 없이 재배포 해야되기 때문

![image](https://github.com/leehjhjhj/reading-books/assets/102458609/e77d74f0-5550-48f4-8684-e13bca86ef8d)

- 데이터베이스를 논리적으로 분할하고, 이를 연합 공유 라이브러리를 통해 명시하는 방법으로 리스크를 낮춘다.
- 5개의 개별 도메인(공통, 고객, 청구, 주문, 추적)으로 논리 분할하고, 도메인 서비스마다 논리 분할한 데이터베이스를 바라보는 전용 공유 라이브러리를 5개 둠
- 이러면 특정 논리 도메인에 속한 테이블을 변경해도, 해당 엔티티 객체가 포함된 서비스만 영향을 받을 뿐, 다른 서비스는 영향을 받지 않는다.
- 또, 수정 권한을 DB팀에만 주는 방법도 있다.

## 아키텍처 예시
![image](https://github.com/leehjhjhj/reading-books/assets/102458609/36812732-9a71-4137-8c4f-be784efaa272)

- 중고 전자 제품 재활용 처리 프로세스
    
    ```
    견적 : 고객이 회사에 연락하여 자신이 소유한 중고 제품을 얼마에 보상받을 수 있는지 문의한다.
    수취 : 고객이 보상가에 만족하면 회사에 제품을 보내고 회사는 실물을 받는다.
    감정 : 재활용 회사는 고객이 보낸 제품의 작동 상태를 꼼꼼히 평가한다.
    회계 : 제품 상태가 좋을 경우 회사는 고객에세 약속한 보상가를 지불한다.
    재활용 : 감정 결과에 따라 제품은 안전하게 해체 후 재활용 되거나 재판매된다.
    회사는 재활용 성과에 따른 임시/정기 재무 리포트를 정기적으로 체크한다.
    제품 상태 : 위의 회계 과정까지 언제라도 고객은 회사 웹사이트에 접속해서 진행 상황을 확인할 수 있다.
    ```
    
- 높은 처리량이 필요한 서비스만 확장하면 됨
- 그 밖은 단일 서비스 인스턴스
- 외부 고객은 내부 기능으로 향하는 네트워크에 접속이 불가, 데이터 베이스도 분리
- 민첩성, 시험성, 배포성은 물론, 확장성, 내고장성, 보안 등 서비스 기반 아키텍처의 많은 장점
- 감정 서비스는 감정 규칙이 꾸준히 변경되기 때문에 잦은 변경을 단일 도메인 서비스로 격리하면 민첩성, 시험성, 배포성을 높일 수 있음

## 언제 이 아키텍처 스타일을 사용하는가

- DDD와 궁합이 잘 맞다.
- 서비스 기반 아키텍처는 복잡하게 뒤얽히거나 세분도의 함정에 빠져 허우적거리지 않고도 아키텍처 모듈성을 괜찮을 수준으로 달성할 수 있다.
- 서비스를 잘게 자르면 오케스트레이션과 코레오그래피가 필요한데, 서비스 기반 아키텍처는 더 큰 단위라 정교한 조율은 필요하지 않다.
